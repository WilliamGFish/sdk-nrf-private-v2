/* dect_mac/dect_mac_security.h */
#ifndef DECT_MAC_SECURITY_H__
#define DECT_MAC_SECURITY_H__

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h> // For size_t
#include "dect_mac_context.h"


/**
 * @brief The size in bytes of the truncated Message Authentication Code (MAC)
 *        used in the DECT NR+ authentication handshake protocol.
 *
 * Per ETSI TS 103 636-4, the full 128-bit (16-byte) AES-CMAC is truncated
 * to 64 bits (8 bytes) for use in the Auth Response and Auth Success IEs.
 */
#define DECT_MAC_AUTH_MAC_SIZE 8


/**
 * @brief Builds the 16-byte Initialization Vector (IV) for AES-CTR encryption.
 *
 * This function constructs the IV according to the precise format defined in
 * ETSI TS 103 636-4, Table 5.9.1.3-1. The IV is a critical component for ensuring
 * that the same key can be used to encrypt multiple packets securely.
 * All multi-byte fields (Long RD IDs, HPC, PSN field) are written in Big Endian format.
 *
 * @param iv_out 16-byte buffer to store the generated IV.
 * @param transmitter_long_rd_id Long RD ID of the transmitter.
 * @param receiver_long_rd_id Long RD ID of the receiver.
 * @param hpc The current 32-bit Hyper Packet Counter to be used for this IV.
 * @param psn The current 12-bit Packet Sequence Number for this packet.
 */
void security_build_iv(uint8_t *iv_out,
                       uint32_t transmitter_long_rd_id,
                       uint32_t receiver_long_rd_id,
                       uint32_t hpc,
                       uint16_t psn);

/**
 * @brief Calculates the 5-byte Message Integrity Code (MIC) using AES-128-CMAC.
 *
 * This function computes a full 16-byte AES-CMAC tag over the provided PDU data
 * (typically MAC Common Header + MAC SDU Area) and then truncates it to the
 * first 5 octets as required by ETSI TS 103 636-4, Clause 5.9.1.2.
 * This provides message authentication.
 *
 * @param pdu_data_for_mic Pointer to the start of the data over which the MIC is calculated.
 * @param pdu_data_len Length of the data for MIC calculation.
 * @param integrity_key Pointer to the 16-byte session integrity key.
 * @param mic_out_5_bytes 5-byte buffer to store the truncated MIC.
 * @return 0 on success, or a negative error code from the crypto driver or for invalid params.
 */
int security_calculate_mic(const uint8_t *pdu_data_for_mic,
                           size_t pdu_data_len,
                           const uint8_t *integrity_key,
                           uint8_t *mic_out_5_bytes);

/**
 * @brief Encrypts or decrypts a payload using AES-128 Counter (CTR) mode.
 *
 * This function performs the cryptographic operation in-place on the provided
 * payload buffer. It is used to provide confidentiality for the specified part of the MAC PDU.
 * The IV's counter portion (last 2 bytes) will be modified by this operation as per CTR mode.
 *
 * @param payload_in_out Pointer to the payload to be encrypted/decrypted in-place.
 * @param len Length of the payload.
 * @param cipher_key Pointer to the 16-byte session cipher key.
 * @param iv Pointer to the 16-byte Initialization Vector (generated by `security_build_iv`).
 *           This IV will be modified by the CTR operation.
 * @param encrypt True to encrypt, false to decrypt.
 * @return 0 on success, or a negative error code from the crypto driver or for invalid params.
 */
int security_crypt_payload(uint8_t *payload_in_out,
                           size_t len,
                           const uint8_t *cipher_key,
                           uint8_t *iv, /* IV is modified in CTR mode */
                           bool encrypt);

// /**
//  * @brief Derives session integrity and cipher keys from a master pre-shared key.
//  *
//  * THIS IS A PLACEHOLDER KDF AND IS NOT SECURE FOR PRODUCTION.
//  * A proper KDF (e.g., HKDF based on AES-CMAC or a standard key derivation function)
//  * should be used, ideally incorporating nonces exchanged during an authentication handshake.
//  * For this phase, it implements a very simple derivation for testing purposes.
//  *
//  * @param master_key Pointer to the 16-byte master pre-shared key.
//  * @param out_session_integrity_key Buffer to store the 16-byte derived integrity key.
//  * @param out_session_cipher_key Buffer to store the 16-byte derived cipher key.
//  * @return 0 on success, negative error code on failure (e.g., NULL pointers).
//  */
// int security_derive_session_keys_from_psk(const uint8_t *master_key,
//                                           uint8_t *out_session_integrity_key,
//                                           uint8_t *out_session_cipher_key);


 /**
 * @brief Derives a dedicated 16-byte authentication key (K_auth) from the master PSK.
 *
 * This function uses a CMAC-based KDF with a fixed label to derive a key used
 * exclusively for the authentication handshake MACs.
 *
 * @param master_key Pointer to the 16-byte master pre-shared key.
 * @param out_auth_key Buffer to store the 16-byte derived authentication key.
 * @return 0 on success, or a negative error code.
 */
int security_derive_auth_key(const uint8_t *master_key, uint8_t *out_auth_key);

/**
 * @brief Generates an 8-byte authentication MAC for the challenge-response handshake.
 *
 * This function implements the core cryptographic operation for the handshake.
 * It computes an AES-128-CMAC over a concatenation of the PT/FT nonces and IDs,
 * using the derived authentication key (K_auth).
 *
 * @param auth_key Pointer to the 16-byte authentication key (K_auth).
 * @param pt_nonce The 32-bit nonce generated by the PT.
 * @param ft_nonce The 32-bit nonce generated by the FT.
 * @param pt_long_id The 32-bit Long RD ID of the PT.
 * @param ft_long_id The 32-bit Long RD ID of the FT.
 * @param out_mac_8_bytes Buffer to store the resulting 8-byte truncated MAC.
 * @return 0 on success, or a negative error code.
 */
int security_generate_auth_mac(const uint8_t *auth_key, uint32_t pt_nonce, uint32_t ft_nonce,
			       uint32_t pt_long_id, uint32_t ft_long_id,
			       uint8_t *out_mac_8_bytes);

/**
 * @brief Derives session integrity and cipher keys from the authentication key (K_auth).
 *
 * This function uses a CMAC-based KDF to derive the final session keys used for
 * data confidentiality and integrity, creating a key hierarchy from the master PSK.
 *
 * @param auth_key Pointer to the 16-byte authentication key (K_auth).
 * @param id_local Long RD ID of the local device.
 * @param id_peer Long RD ID of the peer device.
 * @param out_session_integrity_key Buffer to store the 16-byte derived integrity key.
 * @param out_session_cipher_key Buffer to store the 16-byte derived cipher key.
 * @return 0 on success, negative error code on failure.
 */
int security_derive_session_keys(const uint8_t *auth_key, uint32_t id_local, uint32_t id_peer,
				 uint8_t *out_session_integrity_key,
				 uint8_t *out_session_cipher_key);
                 
#endif /* DECT_MAC_SECURITY_H__ */